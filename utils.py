import json
import os
import asyncio
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from apscheduler.schedulers.background import BackgroundScheduler
from analysis import analyze_cryptos
from telegram.ext import Application
from config import OWNER_ID

USED_SYMBOLS_FILE = "used_symbols.json"
SIGNAL_CACHE_FILE = "top_signals_cache.json"

def reset_cache():
    if os.path.exists(SIGNAL_CACHE_FILE):
        os.remove(SIGNAL_CACHE_FILE)
    if os.path.exists(USED_SYMBOLS_FILE):
        os.remove(USED_SYMBOLS_FILE)

def load_used_symbols():
    if os.path.exists(USED_SYMBOLS_FILE):
        with open(USED_SYMBOLS_FILE, "r") as f:
            return json.load(f)
    return []

def save_used_symbol(symbol):
    used = load_used_symbols()
    used.append(symbol)
    with open(USED_SYMBOLS_FILE, "w") as f:
        json.dump(used[-6:], f)

def load_signal_cache():
    if os.path.exists(SIGNAL_CACHE_FILE):
        with open(SIGNAL_CACHE_FILE, "r") as f:
            return json.load(f)
    return []

def save_signal_cache(signals):
    with open(SIGNAL_CACHE_FILE, "w") as f:
        json.dump(signals, f)

def schedule_daily_signal_check(app: Application, user_id: int):
    scheduler = BackgroundScheduler(timezone="Europe/Moscow")
    loop = asyncio.get_event_loop()
    scheduler.add_job(
        lambda: asyncio.run_coroutine_threadsafe(send_daily_signal(user_id, app), loop),
        "cron", hour=8, minute=0
    )
    scheduler.start()

async def send_signal_message(user_id, context):
    signal_cache = load_signal_cache()
    used_symbols = load_used_symbols()
    signal_to_send = None

    for signal in signal_cache:
        if signal['symbol'] not in used_symbols:
            signal_to_send = signal
            break

    if not signal_to_send:
        await context.bot.send_message(chat_id=user_id, text="–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç.")
        return

    symbol = signal_to_send['symbol']
    price = float(signal_to_send.get("current_price", 0))
    target_price = round(price * 1.05, 4)
    stop_loss = round(price * 0.97, 4)
    probability = signal_to_send.get("probability", "-")
    change_24h = signal_to_send.get("price_change_percentage_24h", "-")

    message = (
        f"üìà *–°–∏–≥–Ω–∞–ª –Ω–∞ —Ä–æ—Å—Ç –º–æ–Ω–µ—Ç—ã {symbol.upper()}*\n"
        f"‚Ä¢ –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: *${price}*\n"
        f"‚Ä¢ –¶–µ–ª—å: *+5% ‚ûú ${target_price}*\n"
        f"‚Ä¢ –°—Ç–æ–ø-–ª–æ—Å—Å: *${stop_loss}*\n"
        f"‚Ä¢ –ò–∑–º–µ–Ω–µ–Ω–∏–µ –∑–∞ 24—á: *{change_24h}%*\n"
        f"‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Ä–æ—Å—Ç–∞: *{probability}%*"
    )

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üîî –°–ª–µ–¥–∏—Ç—å –∑–∞ –º–æ–Ω–µ—Ç–æ–π", callback_data=f"track_{symbol}")]
    ])

    await context.bot.send_message(chat_id=user_id, text=message, parse_mode='Markdown', reply_markup=keyboard)
    save_used_symbol(symbol)

async def send_daily_signal(user_id, app):
    class DummyContext:
        bot = app.bot
    dummy_context = DummyContext()
    await send_signal_message(user_id, dummy_context)

async def debug_analysis_message(user_id, context):
    from analysis import ANALYSIS_LOG
    text = "\n\n".join(ANALYSIS_LOG[-200:])  # –ø–æ—Å–ª–µ–¥–Ω–∏–µ 200 —Å—Ç—Ä–æ–∫

    if not text:
        text = "–ê–Ω–∞–ª–∏–∑ –µ—â—ë –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª—Å—è."

    # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ Telegram: –¥–µ–ª–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ 4000 —Å–∏–º–≤–æ–ª–æ–≤
    chunk_size = 4000
    for i in range(0, len(text), chunk_size):
        chunk = text[i:i+chunk_size]
        await context.bot.send_message(
            chat_id=user_id,
            text=f"*–ê–Ω–∞–ª–∏–∑ –º–æ–Ω–µ—Ç (—á–∞—Å—Ç—å {i // chunk_size + 1}):*\n{chunk}",
            parse_mode='Markdown'
        )

async def debug_cache_message(user_id, context):
    cache = load_signal_cache()
    if not cache:
        await context.bot.send_message(chat_id=user_id, text="–ö—ç—à –ø—É—Å—Ç.")
        return
    formatted = [f"{s['symbol'].upper()} ‚Äî {s['probability']}% ‚Äî ${s['current_price']}" for s in cache]
    await context.bot.send_message(chat_id=user_id, text=f"*–ö—ç—à —Å–∏–≥–Ω–∞–ª–æ–≤:*\n" + "\n".join(formatted), parse_mode='Markdown')
